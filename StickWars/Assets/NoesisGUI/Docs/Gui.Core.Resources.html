<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.11: http://docutils.sourceforge.net/" />
<title>Resources Overview</title>
<link rel="stylesheet" href="style/noesis.css" type="text/css" />
</head>
<body>
<div class="document" id="resources-overview">
<div>
    <div class="headerbg">
        <center><img src="NoesisLogo.png" class="headerimg"/></center>
    </div>
    <div class="headermenu">
        <a href="Gui.Core.Index.html" class="headerlink">Documentation Index</a>
    </div>
</div>
<h1 class="title">Resources Overview</h1>

<div class="section" id="introduction">
<h1>Introduction</h1>
<p>This overview explains how to use resources as a simple way to reuse commonly defined objects and values. It focuses on how to use resources in XAML. You can also create and access resources by using code, or interchangeably between code and XAML.</p>
<p>Every <a class="reference external" href="Gui.Core.FrameworkElement.html">FrameworkElement</a> has a Resources property, which is the property that contains the resources (as a <a class="reference external" href="Gui.Core.ResourceDictionary.html">ResourceDictionary</a>) that an element defines. You can define resources on any element. However, resources are most often defined on the root element of the XAML tree.</p>
<p>Each resource in a resource dictionary must have a unique key. When you define resources in markup, you assign the unique key through the x:Key directive. Typically, the key is a string; however, you can also set it to other object types by using the appropriate markup extensions. Nonstring keys for resources are usally emploed for styles.</p>
<p>After you define a resource, you can reference the resource to be used for a property value by using a resource markup extension syntax that specifies the key name, for example:</p>
<div class="highlight"><pre><span class="nt">&lt;Grid</span>
    <span class="na">xmlns=</span><span class="s">&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span>
    <span class="na">xmlns:x=</span><span class="s">&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span><span class="nt">&gt;</span>

    <span class="nt">&lt;Grid.Resources&gt;</span>
        <span class="nt">&lt;SolidColorBrush</span> <span class="na">x:Key=</span><span class="s">&quot;RedBrush&quot;</span> <span class="na">Color=</span><span class="s">&quot;#80800000&quot;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/Grid.Resources&gt;</span>

    <span class="nt">&lt;Button</span> <span class="na">Background=</span><span class="s">&quot;{StaticResource RedBrush}&quot;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Ellipse</span> <span class="na">Fill=</span><span class="s">&quot;{DynamicResource RedBrush}&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/Grid&gt;</span>
</pre></div>
<p>When you define a resource on the root element, all the elements in the logical tree can access it, and you can reuse the same resource for setting the value of any property that accepts the type that the resource represents. In the previous example, the same RedBrush resource sets two different properties: the Background of a Button, and the Fill of a Rectangle.</p>
</div>
<div class="section" id="static-and-dynamic-resources">
<h1>Static and Dynamic Resources</h1>
<p>A resource can be referenced as either a static resource or a dynamic resource. This is done by using either the StaticResource Markup Extension or the DynamicResource Markup Extension. A markup extension is a feature of XAML whereby you can specify an object reference by having the markup extension process the attribute string and return the object to a XAML loader. For more information about markup extension behavior, see <a class="reference external" href="Gui.Core.MarkupExtensions.html">Markup Extensions</a>.</p>
<p>When you use a markup extension, you typically provide one or more parameters in string form that are processed by that particular markup extension, rather than being evaluated in the context of the property being set. The StaticResource Markup Extension processes a key by looking up the value for that key in all available resource dictionaries. This happens during loading, which is the point in time when the loading process needs to assign the property value that takes the static resource reference. The DynamicResource Markup Extension instead processes a key by creating an expression, and that expression remains unevaluated until the application is actually run, at which time the expression is evaluated and provides a value.</p>
<p><strong>Static Resources</strong></p>
<p>Static resource references work best for the following circumstances:</p>
<ul class="simple">
<li>Your application design concentrates most of all of its resources into window or application level resource dictionaries. Static resource references are not reevaluated based on runtime behaviors and therefore there can be some performance benefit to avoiding large numbers of dynamic resource references when they are not necessary per your resource and application design.</li>
<li>You are setting the value of a property that is not on a DependencyObject or a Freezable.</li>
<li>You are creating a theme for a custom control, and are defining resources that are used within the themes. For this case, you typically do not want the dynamic resource reference lookup behavior, you instead want the static resource reference behavior so that the lookup is predictable and self-contained to the theme.</li>
</ul>
<p>When a StaticResource extension searches for the named resource it follows this lookup behavior:</p>
<ol class="arabic simple">
<li>The lookup process checks for the requested key within the resource dictionary defined by the element that sets the property.</li>
<li>The lookup process then traverses the logical tree upward, to the parent element and its resource dictionary. This continues until the root element is reached.</li>
<li>Next, application resources are checked. Application resources are those resources within the resource dictionary that is defined by the Application object for your application.</li>
</ol>
<p>Static resource references from within a resource dictionary must reference a resource that has already been defined lexically before the resource reference. Forward references cannot be resolved by a static resource reference. For this reason, if you use static resource references, you must design your resource dictionary structure such that resources intended for by-resource use are defined at or near the beginning of each respective resource dictionary.</p>
<p>Static resource lookup can extend into themes; however, static resource references to keys that are known to only exist in themes or as system resources are not recommended. This is because such references are not reevaluated if the theme is changed by the user in realtime. A dynamic resource reference is more reliable when you request theme resources.</p>
<p>If a resource was requested by a dynamic resource reference in XAML, and was not found, then a exception is raised at runtime.</p>
<p><strong>Dynamic Resources</strong></p>
<p>Dynamic resources work best for the following circumstances:</p>
<ul class="simple">
<li>The value of the resource depends on conditions that are not known until runtime. This includes resources that can be user settable. These values are truly dynamic because they ultimately come from the runtime environment of the user. You might also have application-level themes that can change, where window-level resource access must also capture the change.</li>
<li>You are creating or referencing theme styles for a custom control.</li>
<li>You intend to adjust the contents of a ResourceDictionary during an application lifetime.</li>
<li>You have a complicated resource structure that has interdependencies, where a forward reference may be required. Static resource references do not support forward references, but dynamic resource references do support them because the resource does not need to be evaluated until runtime, and forward references are therefore not a relevant concept.</li>
<li>You are creating a style where setter values might come from other values that are influenced by themes or other user settings.</li>
<li>You are applying resources to elements that might be reparented in the logical tree during application lifetime. Changing the parent also potentially changes the resource lookup scope, so if you want the resource for a reparented element to be reevaluated based on the new scope, always use a dynamic resource reference.</li>
</ul>
<p>Resource lookup behavior for a dynamic resource reference parallels the lookup behavior in your code if you call FindResource.</p>
<ol class="arabic simple">
<li>The lookup process checks for the requested key within the resource dictionary defined by the element that sets the property.</li>
</ol>
<blockquote>
<ul class="simple">
<li>If the element defines a Style property, the Resources dictionary within the Style is checked.</li>
<li>If the element defines a Template property, the Resources dictionary within the FrameworkTemplate is checked.</li>
</ul>
</blockquote>
<ol class="arabic simple" start="2">
<li>The lookup process then traverses the logical tree upward, to the parent element and its resource dictionary. This continues until the root element is reached.</li>
<li>Next, application resources are checked. Application resources are those resources within the resource dictionary that is defined by the Application object for your WPF application.</li>
<li>Theme resource dictionary is checked, for the currently active theme. If the theme changes at runtime, the value is reevaluated.</li>
</ol>
<p>Exception behavior varies:</p>
<ul class="simple">
<li>If a resource was requested by a FindResource call, and was not found, an exception is raised.</li>
<li>If a resource was requested by a TryFindResource call, and was not found, no exception is raised, but the returned value is null. If the property being set does not accept null, then it is still possible that a deeper exception will be raised (this depends on the individual property being set).</li>
<li>If a resource was requested by a dynamic resource reference in XAML, and was not found, then the behavior depends on the general property system, but the general behavior is as if no property setting operation occurred at the level where the resource exists. For instance, if you attempt to set the background on a an individual button element using a resource that could not be evaluated, then no value set results, but the effective value can still come from other participants in the property system and value precedence. For instance, the background value might still come from a locally defined button style, or from the theme style. For properties that are not defined by theme styles, the effective value after a failed resource evaluation might come from the default value in the property metadata.</li>
</ul>
<p>Dynamic resource references have some notable restrictions. At least one of the following must be true:</p>
<ul class="simple">
<li>The property being set must be a property on a FrameworkElement. That property must be backed by a DependencyProperty.</li>
<li>The reference is for a value within a Style Setter.</li>
<li>The property being set must be a property on a Freezable that is provided as a value of a FrameworkElement property, or a Setter value.</li>
</ul>
<p>Because the property being set must be a DependencyProperty or Freezable property, most property changes can propagate to UI because a property change (the changed dynamic resource value) is acknowledged by the property system. Most controls include logic that will force another layout of a control if a DependencyProperty changes and that property might affect layout. However, not all properties that have a DynamicResource Markup Extension as their value are guaranteed to provide the value in such a way that they update in realtime in the UI. That functionality still might vary depending on the property, as well as depending on the type that owns the property, or even the logical structure of your application.</p>
</div>
<div class="section" id="styles-and-implicit-keys">
<h1>Styles and Implicit Keys</h1>
<p>Earlier, it was stated that all items in a ResourceDictionary must have a key. However, that does not mean that all resources must have an explicit x:Key. Several object types support an implicit key when defined as a resource, where the key value is tied to the value of another property. This is known as an implicit key, whereas an x:Key attribute is an explicit key. You can overwrite any implicit key by specifying an explicit key.</p>
<p>One very important scenario for resources is when you define a Style. In fact, a Style is almost always defined as an entry in a resource dictionary, because styles are inherently intended for reuse. For more information about styles, see <a class="reference external" href="Gui.Core.Styles.html">Styling and Templating</a>.</p>
<p>Styles for controls can be both created with and referenced with an implicit key. The theme styles that define the default appearance of a control rely on this implicit key. The implicit key from the standpoint of requesting it is the Type of the control itself. The implicit key from the standpoint of defining the resource is the TargetType of the style. Therefore, if you are creating themes for custom controls, creating styles that interact with existing theme styles, you do not need to specify an x:Key Directive for that Style. And if you want to use the themed styles, you do not need to specify any style at all. For instance, the following style definition works, even though the Style resource does not appear to have a key:</p>
<div class="highlight"><pre><span class="nt">&lt;Grid.Resources&gt;</span>
    <span class="nt">&lt;Style</span> <span class="na">TargetType=</span><span class="s">&quot;Button&quot;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;Setter</span> <span class="na">Property=</span><span class="s">&quot;Background&quot;</span><span class="nt">&gt;</span>
            <span class="nt">&lt;Setter.Value&gt;</span>
                <span class="nt">&lt;LinearGradientBrush&gt;</span>
                    <span class="nt">&lt;GradientStop</span> <span class="na">Offset=</span><span class="s">&quot;0.0&quot;</span> <span class="na">Color=</span><span class="s">&quot;Red&quot;</span><span class="nt">/&gt;</span>
                    <span class="nt">&lt;GradientStop</span> <span class="na">Offset=</span><span class="s">&quot;1.0&quot;</span> <span class="na">Color=</span><span class="s">&quot;Orange&quot;</span><span class="nt">/&gt;</span>
                <span class="nt">&lt;/LinearGradientBrush&gt;</span>
            <span class="nt">&lt;/Setter.Value&gt;</span>
        <span class="nt">&lt;/Setter&gt;</span>
        <span class="nt">&lt;Setter</span> <span class="na">Property=</span><span class="s">&quot;FontSize&quot;</span> <span class="na">Value=</span><span class="s">&quot;18&quot;</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/Style&gt;</span>
<span class="nt">&lt;/Grid.Resources&gt;</span>
</pre></div>
<p>That style really does have a key: the implicit key TypeOf&lt;Button&gt;(). In markup, you can specify a TargetType directly as the type name (or you can optionally use {x:Type...} to return a type.</p>
<p>Through the default theme style mechanisms, that style is applied as the runtime style of a Button on the Grid subtree, even though the Button itself does not attempt to specify its Style property or a specific resource reference to the style. Your style defined in the tree is found earlier in the lookup sequence earlier than the theme dictionary style, using the same key that the theme dictionary style has. You could just specify &lt;Button&gt;Hello&lt;/Button&gt; anywhere in the tree, and the style you defined with TargetType of Button would apply to that button. If you want, you can still explicitly key the style with the same type value as TargetType, for clarity in your markup, but that is optional.</p>
<div class="highlight"><pre><span class="nt">&lt;Grid.Resources&gt;</span>
    <span class="nt">&lt;Style</span> <span class="na">x:Key=</span><span class="s">&quot;{x:Type Button}&quot;</span> <span class="na">TargetType=</span><span class="s">&quot;{x:Type Button}&quot;</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/Grid.Resources&gt;</span>
</pre></div>
<p>Implicit keys for styles do not apply on a control if OverridesDefaultStyle is true (also note that OverridesDefaultStyle might be set as part of native behavior for the control class, rather than explicitly on an instance of the control). If you set OverridesDefaultStyle to true on a control, you will be suppressing the default control template supplied by the theme styles. Also, in order to support implicit keys for derived class scenarios, the control must override DefaultStyleKey property (all existing controls provided as part of Noesis GUI do this).</p>
</div>
<div class="section" id="organizing-xaml-resources">
<h1>Organizing XAML Resources</h1>
<p>Resources provide a nice way to factor your XAML within a tree. And if you store them as application-level resources, they can live in a separate XAML file. But if you want to partition a set of resources into arbitrary XAML files no matter where they are stored in the logical tree (perhaps for maintainability or flexibility), you can leverage the MergedDictionaries property of the ResourceDictionary class to achieve this.</p>
<p>For example, a Window could set its Resources collection as follows to merge together multiple resource dictionaries from separate files:</p>
<div class="highlight"><pre><span class="nt">&lt;Window.Resources&gt;</span>
    <span class="nt">&lt;ResourceDictionary&gt;</span>
        <span class="nt">&lt;ResourceDictionary.MergedDictionaries&gt;</span>
            <span class="nt">&lt;ResourceDictionary</span> <span class="na">Source=</span><span class="s">&quot;CommonResources.xaml&quot;</span><span class="nt">/&gt;</span>
            <span class="nt">&lt;ResourceDictionary</span> <span class="na">Source=</span><span class="s">&quot;MainWindowResources.xaml&quot;</span><span class="nt">/&gt;</span>
        <span class="nt">&lt;/ResourceDictionary.MergedDictionaries&gt;</span>
    <span class="nt">&lt;/ResourceDictionary&gt;</span>
<span class="nt">&lt;/Window.Resources&gt;</span>
</pre></div>
<p>The separate files must use ResourceDictionary as the root element. For example, CommonResources.xaml could contain:</p>
<div class="highlight"><pre><span class="nt">&lt;ResourceDictionary</span>
    <span class="na">xmlns=</span><span class="s">&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;</span>
    <span class="na">xmlns:x=</span><span class="s">&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;SolidColorBrush</span> <span class="na">x:Key=</span><span class="s">&quot;RedBrush&quot;</span> <span class="na">Color=</span><span class="s">&quot;#80800000&quot;</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/ResourceDictionary&gt;</span>
</pre></div>
<p>If the dictionaries being merged have a duplicate key, the last one wins (unlike the case of having duplicate keys in a single dictionary).</p>
</div>
<br/>
<div>
    <div class="headerbg">
        <div class="footertext" style="height:32px; background:#262626;">
            &nbsp;<br/>2013 (C) Noesis Technologies
        </div>
    </div>
</div>
</div>
</body>
</html>
