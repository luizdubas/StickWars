<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.11: http://docutils.sourceforge.net/" />
<title>Strings and Symbols</title>
<link rel="stylesheet" href="style/noesis.css" type="text/css" />
</head>
<body>
<div class="document" id="strings-and-symbols">
<div>
    <div class="headerbg">
        <center><img src="NoesisLogo.png" class="headerimg"/></center>
    </div>
    <div class="headermenu">
        <a href="Gui.Core.Index.html" class="headerlink">Documentation Index</a>
    </div>
</div>
<h1 class="title">Strings and Symbols</h1>

<p>Two kinds of strings are supported in Noesis (both declared in the header for Noesis Types, <strong>NsCore/Types.h</strong>):</p>
<ul class="simple">
<li>C strings: arrays of chars using <strong>NsChar</strong> type</li>
<li>C++ strings: stl strings using <strong>NsString</strong></li>
</ul>
<p>By default, string types default to unicode or multybyte as defined in the current configuration file. For specific character usage there are defined types: <em>NsChar8</em>, <em>NsChar16</em>, <em>NsString8</em> and <em>NsString16</em>.</p>
<p>To generate code that is compatible with both unicode and multybyte builds, the macro <strong>NST</strong> must be used to enclose text declared in the source. For example:</p>
<div class="highlight"><pre><span class="n">NsString</span> <span class="nf">value</span><span class="p">(</span><span class="n">NST</span><span class="p">(</span><span class="s">&quot;A sample String&quot;</span><span class="p">));</span>
</pre></div>
<p>Simple chars should be inside NST too:</p>
<div class="highlight"><pre><span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&gt;=</span> <span class="n">NST</span><span class="p">(</span><span class="sc">&#39;A&#39;</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="n">NST</span><span class="p">(</span><span class="sc">&#39;Z&#39;</span><span class="p">))</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">c</span> <span class="o">+</span> <span class="n">NST</span><span class="p">(</span><span class="sc">&#39;a&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="n">NST</span><span class="p">(</span><span class="sc">&#39;A&#39;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<div class="section" id="nschar-vs-nsstring">
<h1>NsChar vs NsString</h1>
<p>NsChar is used as input and output to functions to avoid moving memory when it is not necessary.
NsString are used as class members. The following is an example showing this use of both types:</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Name</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">SetName</span><span class="p">(</span><span class="k">const</span> <span class="n">NsChar</span><span class="o">*</span> <span class="n">name</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">mName</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="n">NsChar</span><span class="o">*</span> <span class="n">GetName</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">mName</span><span class="p">.</span><span class="n">c_str</span><span class="p">();</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="n">NsString</span> <span class="n">mName</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="section" id="nschar-functions">
<h1>NsChar functions</h1>
<p>Standard C string functions (strcpy, strcmp) should be avoided. The functions declared in <strong>NsCore/String.h</strong> should be used instead. These functions are:</p>
<ul class="simple">
<li>Overloaded for Unicode/MultiByte</li>
<li>Safer that standard functions. For example, they force you to give a size for destination buffers. They avoid writing past the limits of the buffers.</li>
<li>Platform independant. These functions can be used in all the platforms where Noesis can be compiled.</li>
</ul>
<table border="1" class="docutils">
<colgroup>
<col width="17%" />
<col width="83%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Function</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>ToString16()</td>
<td>Converts from NsChar8/NsChar16/String8/String16 to NsString16</td>
</tr>
<tr><td>ToString8()</td>
<td>Converts from NsChar8/NsChar16/String8/String16 to NsString8</td>
</tr>
<tr><td>ToString()</td>
<td>Converts from NsChar8/NsChar16/String8/String16 to NsString</td>
</tr>
<tr><td>ToChar16()</td>
<td>Converts from NsChar8/NsChar16/String8/String16 to NsChar16</td>
</tr>
<tr><td>ToChar8()</td>
<td>Converts from NsChar8/NsChar16/String8/String16 to NsChar8</td>
</tr>
<tr><td>ToChar()</td>
<td>Converts from NsChar8/NsChar16/String8/String16 to NsChar</td>
</tr>
<tr><td>IsNullOrEmpty()</td>
<td>Indicates whether the specified string is null or an empty string</td>
</tr>
<tr><td>Length()</td>
<td>Gets the number of characters in this string</td>
</tr>
<tr><td>Compare()</td>
<td>Compares two strings or substrings ignoring or honoring their case</td>
</tr>
<tr><td>CompareFirst()</td>
<td>Compares the first characters in two strings ignoring or honoring their case</td>
</tr>
<tr><td>StartsWith()</td>
<td>Determines whether the beginning of a string matches the specified string</td>
</tr>
<tr><td>EndsWith()</td>
<td>Determines whether the end of a string matches the specified string</td>
</tr>
<tr><td>FindFirst()</td>
<td>Reports the index of the first occurrence of the specified string in a string. The search
starts at a specified character position and examines a specified number of character positions</td>
</tr>
<tr><td>FindLast()</td>
<td>Reports the index of the last occurrence of the specified string in a string. The search
starts at a specified character position and examines a specified number of character positions</td>
</tr>
<tr><td>Copy()</td>
<td>Copies a specified number of characters of a specified string to an existing string
until its capacity is reached</td>
</tr>
<tr><td>Append()</td>
<td>Appends a specified number of characters of a specified string to an existing string
until its capacity is reached</td>
</tr>
<tr><td>Replace()</td>
<td>Replaces all occurrences of a specified string, with another specified string</td>
</tr>
<tr><td>Format()</td>
<td>Formats a NsString using printf-like format</td>
</tr>
<tr><td>Printf()</td>
<td>Write formatted data to the standard output stream or to a string</td>
</tr>
<tr><td>PrintfArgs()</td>
<td>Write formatted data to a string using a pointer to a list of arguments</td>
</tr>
<tr><td>ToLower()</td>
<td>Converts, in place, any uppercase letters in a string to lowercase</td>
</tr>
<tr><td>ToUpper()</td>
<td>Converts, in place, any uppercase letters in a string to uppercase</td>
</tr>
<tr><td>Trim()</td>
<td>Removes all occurrences of a set of characters from the beginning and/or end of a string</td>
</tr>
<tr><td>Hash()</td>
<td>Calculate the hash value of a string. This function is case-sensitive</td>
</tr>
<tr><td>IHash()</td>
<td>Calculate the case-insensitive hash value of a string</td>
</tr>
<tr><td>ToInteger()</td>
<td>Conversion of text to integer</td>
</tr>
<tr><td>ToFloat()</td>
<td>Conversion of text to float</td>
</tr>
<tr><td>ToBool()</td>
<td>Conversion of text to boolean</td>
</tr>
<tr><td>IsAlpha()</td>
<td>Checking for an alphabetic character</td>
</tr>
<tr><td>IsAlphaNum()</td>
<td>Checking for an alphanumeric character</td>
</tr>
<tr><td>IsDigit()</td>
<td>Checking for a decimal-digit character</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="symbols">
<h1>Symbols</h1>
<p>Symbols is a term used in Noesis Engine for referring to inmutable strings that are stored in a symbol table and identified by an index to that table. Once a symbol is added to the table it remains there until the end of the program. Symbols are used in Noesis to represent strings defined at compile time.</p>
<p>As the implementation of a symbol is an index, the comparison between symbols is extremely efficient. When several symbols refer to the same string only one string is stored in the symbol table.</p>
<p>Symbols are <strong>Case-Insensitive</strong>, but it's recommended that the Upper Mixed Case naming scheme described in the <a class="reference external" href="Core.Kernel.CodingStyleGuide.html">Coding Style Guide</a> is used, specially for symbols that will be converted back to strings for visualization (for example, profiling marks).</p>
<p>The macros NS_DECLARE_SYMBOL and NSS allows for easily using symbols in a efficient way:</p>
<div class="highlight"><pre><span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>
<span class="n">NS_DECLARE_SYMBOL</span><span class="p">(</span><span class="n">GameTopPanel</span><span class="p">)</span>

<span class="c1">////////////////////////////////////////////////////////////////////////////////////////////////////</span>
<span class="kt">void</span> <span class="n">BaseGame</span><span class="o">::</span><span class="n">Init</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// cache important UI elements</span>
    <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">INameScope</span><span class="o">&gt;</span> <span class="n">nameScope</span> <span class="o">=</span> <span class="n">mGamePanel</span><span class="p">;</span>

    <span class="c1">// game top panel</span>
    <span class="n">mTopPanel</span> <span class="o">=</span> <span class="n">nameScope</span><span class="o">-&gt;</span><span class="n">FindName</span><span class="p">(</span><span class="n">NSS</span><span class="p">(</span><span class="n">GameTopPanel</span><span class="p">));</span>
    <span class="n">NS_ASSERT</span><span class="p">(</span><span class="n">mTopPanel</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<div class="section" id="watching-symbols-in-the-debugger">
<h2>Watching symbols in the debugger</h2>
<p>For converting symbol ids to strings and vice versa the functions NsSymbolToString and NsStringToSymbol can be pasted into the Watch window using the following syntax:</p>
<div class="highlight"><pre><span class="p">{,,</span><span class="n">Debug</span><span class="p">.</span><span class="n">Core</span><span class="p">.</span><span class="n">Kernel</span><span class="p">.</span><span class="n">dll</span><span class="p">}</span><span class="n">NsSymbolToString</span><span class="p">(</span><span class="mi">1146</span><span class="p">)</span>
<span class="p">{,,</span><span class="n">Debug</span><span class="p">.</span><span class="n">Core</span><span class="p">.</span><span class="n">Kernel</span><span class="p">.</span><span class="n">dll</span><span class="p">}</span><span class="n">NsStringToSymbol</span><span class="p">(</span><span class="s">L&quot;DiskFileSystem&quot;</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="watching-symbols-in-the-console">
<h2>Watching symbols in the console</h2>
<p>Each symbol created is logged to the console in a symbol section for debugging purposes.</p>
</div>
<div class="section" id="note-on-symbols-efficiency">
<h2>Note on symbols efficiency</h2>
<p>The pair of macros <strong>NS_DECLARE_SYMBOL</strong> and <strong>NSS</strong> use a static to hold the symbol. This implies that:</p>
<ul class="simple">
<li>If you use lots of symbols, code bloat could appear</li>
<li>The use of the <strong>NSS</strong> macro implies and <em>if</em> before accessing the symbol to check if it has been initialized. Most of the times this has zero impact in the performance but it is useful to know what is going on under that macros.</li>
</ul>
</div>
<div class="section" id="when-to-use-symbols">
<h2>When to use Symbols</h2>
<p>It is a good idea to use symbols in this situation:</p>
<ul class="simple">
<li>When the strings are created and not destroyed until finishing the application</li>
<li>When those strings are used as the key in a container</li>
<li>When you are going to compare those strings</li>
</ul>
</div>
</div>
<br/>
<div>
    <div class="headerbg">
        <div class="footertext" style="height:32px; background:#262626;">
            &nbsp;<br/>2013 (C) Noesis Technologies
        </div>
    </div>
</div>
</div>
</body>
</html>
