<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.11: http://docutils.sourceforge.net/" />
<title>ScopeGuard</title>
<link rel="stylesheet" href="style/noesis.css" type="text/css" />
</head>
<body>
<div class="document" id="scopeguard">
<div>
    <div class="headerbg">
        <center><img src="NoesisLogo.png" class="headerimg"/></center>
    </div>
    <div class="headermenu">
        <a href="Gui.Core.Index.html" class="headerlink">Documentation Index</a>
    </div>
</div>
<h1 class="title">ScopeGuard</h1>

<p>ScopeGuard is a useful mechanism to automatically invoke an &quot;undo&quot; operation of your choosing when it goes out of scope. As a <a class="reference external" href="http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">RAII</a> mechanism it can very handy to &quot;rollback&quot; to a previous state when an exception is thrown. Due to its simplicity it can be used in more scenarios, not only when exceptions can appear.</p>
<div class="section" id="usage">
<h1>Usage</h1>
<p>Basically, when you want to register an action that may need &quot;rolling back&quot; you create a ScopeGuard instance with the function in charge of the undo operation and all the needed parameter. ScopeGuard supports all type of functors: free functions and member functions. Whenever you arrive to a safe state that does not need the &quot;undo&quot; operation you invoke the Dismiss() method of ScopeGuard. This operation disables the &quot;undo&quot; operation.</p>
<div class="highlight"><pre><span class="k">class</span> <span class="nc">Manager</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">Manager</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">mFile</span> <span class="o">=</span> <span class="n">File</span><span class="o">::</span><span class="n">Open</span><span class="p">(</span><span class="s">&quot;info.dat&quot;</span><span class="p">,</span> <span class="s">&quot;rb&quot;</span><span class="p">);</span>
        <span class="n">ScopeGuard</span> <span class="n">guard</span> <span class="o">=</span> <span class="n">MakeGuard</span><span class="p">(</span><span class="o">&amp;</span><span class="n">File</span><span class="o">::</span><span class="n">Close</span><span class="p">,</span> <span class="n">mFile</span><span class="p">);</span>

        <span class="c1">// This operation may raise an exception. If an exception is generated the scopeguard</span>
        <span class="c1">// will close the opened file handle</span>
        <span class="n">ReadDatabase</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>

        <span class="c1">// Ok, we are now in a safe state. We do not need closing the handle because it is needed</span>
        <span class="c1">// by this instance</span>
        <span class="n">guard</span><span class="p">.</span><span class="n">Dismiss</span><span class="p">();</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="kt">FILE</span><span class="o">*</span> <span class="n">mFile</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
<p>When the Dismiss() operation is nos needed, that is, when you need the undo operation to be executed always, you can use the macro <strong>NS_ON_SCOPE_EXIT</strong> that simplifies the Scope guard usage.</p>
<div class="highlight"><pre><span class="kt">void</span> <span class="nf">RegisterDirectory</span><span class="p">(</span><span class="k">const</span> <span class="n">NsChar</span><span class="o">*</span> <span class="n">directory</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">UINT</span> <span class="n">errorMode</span> <span class="o">=</span> <span class="n">SetErrorMode</span><span class="p">(</span><span class="n">SEM_FAILCRITICALERRORS</span><span class="p">);</span>
    <span class="n">NS_ON_SCOPE_EXIT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">SetErrorMode</span><span class="p">,</span> <span class="n">errorMode</span><span class="p">);</span>

    <span class="c1">///</span>
    <span class="c1">/// Rest of the function</span>
    <span class="c1">///</span>

    <span class="c1">/// When leaving this function the ScopeGuard mechanism will restore the initial ErrorMode</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="additional-documentation">
<h1>Additional documentation</h1>
<p>ScopeGuard implementation is based on the work by Andrei Alexandrescu and Petru Marginean.</p>
<ul class="simple">
<li><a class="reference external" href="http://www.ddj.com/cpp/184403758">Generic: Change the Way You Write Exception-Safe Code Forever</a></li>
<li><a class="reference external" href="http://www.zete.org/people/jlehrer/scopeguard.html">Improvements by Joshua Lehrer</a></li>
</ul>
</div>
<br/>
<div>
    <div class="headerbg">
        <div class="footertext" style="height:32px; background:#262626;">
            &nbsp;<br/>2013 (C) Noesis Technologies
        </div>
    </div>
</div>
</div>
</body>
</html>
