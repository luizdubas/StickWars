<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.11: http://docutils.sourceforge.net/" />
<title>NoesisEngine Architecture Layers</title>
<link rel="stylesheet" href="style/noesis.css" type="text/css" />
</head>
<body>
<div class="document" id="noesisengine-architecture-layers">
<div>
    <div class="headerbg">
        <center><img src="NoesisLogo.png" class="headerimg"/></center>
    </div>
    <div class="headermenu">
        <a href="Gui.Core.Index.html" class="headerlink">Documentation Index</a>
    </div>
</div>
<h1 class="title">NoesisEngine Architecture Layers</h1>

<p>There are, at least, two possible ways to view the logical organization of NoesisSDK. One is as a set of modules where the packages belongs to. The other one is decomposing the organization in several usage layers. Both logical views are described in this section.</p>
<div class="section" id="modules">
<h1>Modules</h1>
<p>Modules are high-level categories used to classify the package network. To identify a package, the module it belongs to is used as part of the identifier. For example, the full qualified name for the VirtualFileSystem package is File/VirtualFileSystem. To simplify the organization, there is only one hierarchical level of modules. Each module is stored physically in a folder inside the packages directory. All the packages belonging to that module are stored inside that folder. See <a class="reference external" href="Core.Kernel.SDKStructure.html">SDK</a> for more information.</p>
<p>What follows is a brief description of the main modules that compose Noesis Engine.</p>
<div class="section" id="core">
<h2>Core</h2>
<p>This is the module where low-level packages, in direct contact with the operating system are stored. The <strong>Kernel</strong> package is located in this module. This package is the main entry point for initializing the SDK. The Kernel controls the lifetime of the memory manager, logger and component factory. Kernel systems are managed by the Kernel. The reflection information of each component is stored inside the kernel. This information is accessible to other modules.</p>
<p>The <strong>Serialization</strong> package is implemented in this category too. This package offers the functionality to save and load component information to streams. The serialization format is used by all the modules that want to save or load information from a file, network, etc.</p>
<p>The <strong>Configsystem</strong> package offers configuration functionality to other systems. Inside the configsystem all kind of configuration properties can be stored (and they can be stored inside a file). The <strong>Commandsystem</strong> connects the configsystem with the console and offers the possibility to execute remotely commands and interacts with the configsystem.</p>
<p>The <strong>Tasksystem</strong> is used to decompose high level algorithms in small tasks that can be easily parallelized. This package is used to obtain the maximum benefit from all the hardware threads that can be found in the different architectures.</p>
</div>
<div class="section" id="file">
<h2>File</h2>
<p>This is the module for file related packages. The different filesystems are implemented here. A filesystem offers an uniform access to a container of files. Examples of filesystem include the <strong>DiskFileSystem</strong> for files stored in the harddisk, <strong>ZipFileSystem</strong> for files stored inside a zip, etc.</p>
<p>The <strong>VirtualFileSystem</strong> package allows for hooking different filesystem inside a common namespace. It offers an abstraction to access the different filesystem in an uniform way. This way, a program can load files without knowing the exact location of each file. They could be stored in the disk, in the network, inside a zip.</p>
</div>
<div class="section" id="math">
<h2>Math</h2>
<p>Packages related to math are stored here. The <strong>VectorMath</strong> package is located here. It offers implementation for vector, matrices, quaterions and related operations.</p>
<p>The <strong>Tessellation</strong> package implements different tessellation algorithms.</p>
</div>
<div class="section" id="import">
<h2>Import</h2>
<p>All the data importers are located here. The <strong>ColladaMeshImporter</strong> imports geometries and materials from collada files. The <strong>ImageImporter</strong> imports typical image files like jpeg, tga, gif, png, dds, etc. <strong>ShaderImporter</strong> is able to import shader files to be used by the Render. <strong>SoundImporter</strong> reads sound file formats (wav, ogg).</p>
<p>The <strong>ImporterSystem</strong> offers an interface to import all kind of formats. It maintains a database of source files and imported files that can be used to easily regenerate any resource in the database.</p>
</div>
<div class="section" id="gui">
<h2>GUI</h2>
<p>Packages related to User Interface are classified under this module. Noesis GUI System is implemented here. The <strong>UISystem</strong> implements a XAML interpreter that is able to render widgets described in that language.</p>
</div>
<div class="section" id="drawing">
<h2>Drawing</h2>
<p>The <strong>Image</strong>, a platform independent bitmap class, is implemented here with typical operations like conversion between different formats, resizing, cropping, rotation, etc.
The <strong>VGL</strong>, a vector graphic library, is located inside this module. It offers an interface very similar to OpenVG and is implemented using the rendersystem. The <strong>FontRenderer</strong>, implements the font rasterizer using the VGL. The UISystem uses both he VGL and FontRenderer to draw the different GUI controls.</p>
</div>
<div class="section" id="render">
<h2>Render</h2>
<p>Inside the render module you find all packages related to 3D Rendering. Implementations for each platform of the RenderSystem are located here. The <strong>DX9RenderSystem</strong> implements the RenderSystem using the DirectX v9.0 API.</p>
<p>Other packages related to the render driver are located here too. For example, the <strong>VCacheOptimizer</strong> offers an vertex cache optimizer that can be used to improve the render efficiency ofvertex buffers.</p>
</div>
<div class="section" id="audio">
<h2>Audio</h2>
<p>The audio driver is implemented here. The <strong>AudioSystem</strong> package offers the public platform independent interface for the driver. <strong>OALAudioSystem</strong> implements a driver using the OpenAL API.</p>
</div>
<div class="section" id="scene">
<h2>Scene</h2>
<p>Scene packages are related to high level rendering and algorithms like culling, kd-tree, light calculations, shadow mapping, etc.</p>
</div>
<div class="section" id="input">
<h2>Input</h2>
<p>Packages related to input devices are located under this module. The <strong>InputSystem</strong> offers functionality to read from keyboard, mouse and joysticks. Physical inputs can be mapped to virtual inputs allowing the application to read input that can be easily redefined using the configsystem.</p>
</div>
<div class="section" id="logic">
<h2>Logic</h2>
<p>In the Logic module, packages associated to the logic part of an application or game can be found. The <strong>Entity</strong> package implements the entity layer. The entity layer is an abstraction very useful to describe how an application interacts. Each entity is composed of several components that interacts using messages. Entity components allows for easily reusing functionality among different entities.</p>
</div>
</div>
<div class="section" id="layers">
<h1>Layers</h1>
<p>NoesisSDK is structured in layers with each layer based in the previous one. From low-level to high-level we find the Kernel Layer, the System Layer and the Application Layer. What follows is a description of each one.</p>
<div class="section" id="kernel-layer">
<h2>Kernel Layer</h2>
<p>The kernel layer is defined in the Core/Kernel package as a <a class="reference external" href="Core.Kernel.Singletons.html">singleton</a>. Before using any other part of the SDK, the kernel must be properly initialized. Core/Kernel is the unique package that is a mandatory dependency for the rest of the packages. A minimal Noesis distribution is the Core/Kernel package (and its dependencies, like the Core/Parser and Core/UnitTestSystem for example)</p>
<div class="highlight"><pre><span class="c1">// Minimal example of Noesis Initialization</span>
<span class="n">NS_TRY</span>
<span class="p">{</span>

    <span class="n">IKernel</span><span class="o">*</span> <span class="n">kernel</span> <span class="o">=</span> <span class="n">NsGetKernel</span><span class="p">();</span>

    <span class="n">kernel</span><span class="o">-&gt;</span><span class="n">Init</span><span class="p">();</span>

    <span class="c1">// Kernel initialized</span>
    <span class="n">NS_INFO</span><span class="p">(</span><span class="n">NST</span><span class="p">(</span><span class="s">&quot;Inside Noesis!&quot;</span><span class="p">));</span>
    <span class="c1">// ...</span>

    <span class="n">kernel</span><span class="o">-&gt;</span><span class="n">Shutdown</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">NS_CATCH</span>
<span class="p">{</span>
    <span class="n">NS_SHOW_ERRORDIALOG</span><span class="p">;</span>
    <span class="n">NS_CLEAR_CRITICALFLAG</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>The kernel implements the core functionality of the engine through <a class="reference external" href="Core.Kernel.KernelModules.html">kernel modules</a>. The kernel <em>Init()</em> function initializes each kernel module in the appropiate order and kernel <em>Shutdown()</em> destroy them in reverse order.</p>
<p>The kernel is designed to be:</p>
<ul class="simple">
<li><strong>Monolithic</strong>: Packages are not available in this layer, so kernel modules forming part of the Kernel are statically determined.</li>
<li><strong>Minimalist</strong>: Due to previous point, kernel should be as small as possible. All the functionality that could be implemented in the System Layer must be done at that level.</li>
</ul>
</div>
<div class="section" id="kernel-system-layer">
<h2>Kernel System Layer</h2>
<p>A Kernel System is a normal <a class="reference external" href="Core.Kernel.Component.html">component</a> implementing the IKernelSystem interface. As a normal component, the organization of Kernel System in <a class="reference external" href="Core.Kernel.Package.html">packages</a> is totally arbitrary. This is the layer where most of the reusable work should be implemented and it is the better way to expand the kernel functionality.</p>
<p>KernelSystems are described in more depth in the <a class="reference external" href="Core.Kernel.KernelSystems.html">KernelSystem</a> section of the core documentation.</p>
<p>Examples of Kernel System are: ConfigSystem, CommandSystem, RemoteCommandSystem, RenderSystem, UnitTestSystem</p>
<p>Before initializing any system, components should be registered:</p>
<div class="highlight"><pre><span class="n">kernel</span><span class="o">-&gt;</span><span class="n">RegisterDirectory</span><span class="p">(</span><span class="n">NST</span><span class="p">(</span><span class="s">&quot;AppDllDirectory&quot;</span><span class="p">));</span>
</pre></div>
<p>After that, Kernel Systems are explicitly initialized using system class identifier:</p>
<div class="highlight"><pre><span class="n">kernel</span><span class="o">-&gt;</span><span class="n">AddSystem</span><span class="p">(</span><span class="n">NSS</span><span class="p">(</span><span class="s">&quot;ConfigSystem&quot;</span><span class="p">));</span>
<span class="n">kernel</span><span class="o">-&gt;</span><span class="n">AddSystem</span><span class="p">(</span><span class="n">NSS</span><span class="p">(</span><span class="s">&quot;CommandSystem&quot;</span><span class="p">));</span>
<span class="n">kernel</span><span class="o">-&gt;</span><span class="n">AddSystem</span><span class="p">(</span><span class="n">NSS</span><span class="p">(</span><span class="s">&quot;RemoteCommandSystem&quot;</span><span class="p">));</span>
</pre></div>
<p>Initialized Kernel Systems can be accessed from the kernel like <a class="reference external" href="Core.Kernel.Singletons.html">singleton</a>:</p>
<div class="highlight"><pre><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">IConfigSystem</span><span class="o">&gt;</span> <span class="n">configSystem</span> <span class="o">=</span> <span class="n">kernel</span><span class="o">-&gt;</span><span class="n">GetSystem</span><span class="p">(</span><span class="n">NSS</span><span class="p">(</span><span class="s">&quot;ConfigSystem&quot;</span><span class="p">));</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">ICommandSystem</span><span class="o">&gt;</span> <span class="n">commandSystem</span> <span class="o">=</span> <span class="n">kernel</span><span class="o">-&gt;</span><span class="n">GetSystem</span><span class="p">(</span><span class="n">NSS</span><span class="p">(</span><span class="s">&quot;CommandSystem&quot;</span><span class="p">));</span>
</pre></div>
<p>A user identifier could be assigned to any system instance, and use it instead of class identifier:</p>
<div class="highlight"><pre><span class="n">kernel</span><span class="o">-&gt;</span><span class="n">AddSystem</span><span class="p">(</span><span class="n">NSS</span><span class="p">(</span><span class="s">&quot;DX9RenderSystem&quot;</span><span class="p">),</span> <span class="n">NSS</span><span class="p">(</span><span class="s">&quot;RenderSystem&quot;</span><span class="p">));</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">IRenderSystem</span><span class="o">&gt;</span> <span class="n">renderSystem</span> <span class="o">=</span> <span class="n">kernel</span><span class="o">-&gt;</span><span class="n">GetSystem</span><span class="p">(</span><span class="n">NSS</span><span class="p">(</span><span class="s">&quot;RenderSystem&quot;</span><span class="p">));</span>
</pre></div>
<p>Kernel Systems are uninitialized (when calling <em>Kernel::Shutdown()</em>) in the reverse order of initialization.</p>
</div>
<div class="section" id="application-layer">
<h2>Application Layer</h2>
<p>Applications are derived from specific platform dependant classes implemented in the GUI/Application package. For example, a Windows application must inherit from Gui::WindowsApplication.</p>
</div>
</div>
<br/>
<div>
    <div class="headerbg">
        <div class="footertext" style="height:32px; background:#262626;">
            &nbsp;<br/>2013 (C) Noesis Technologies
        </div>
    </div>
</div>
</div>
</body>
</html>
