<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.11: http://docutils.sourceforge.net/" />
<title>Reference Counting</title>
<link rel="stylesheet" href="style/noesis.css" type="text/css" />
</head>
<body>
<div class="document" id="reference-counting">
<div>
    <div class="headerbg">
        <center><img src="NoesisLogo.png" class="headerimg"/></center>
    </div>
    <div class="headermenu">
        <a href="Gui.Core.Index.html" class="headerlink">Documentation Index</a>
    </div>
</div>
<h1 class="title">Reference Counting</h1>

<p>Reference counting is a technique of storing the number of references to a resource such as an object or block of memory. It is typically used as a means of deallocating objects which are no longer referenced. It is the simplest implementation of <strong>Garbage Collection</strong>. Each object contains a count of the number of pointers referring to it, held by other objects. If an object's reference count reaches zero the object is no longer referenced and it can be safely destroyed.</p>
<p>Components in NoesisEngine inherit from <em>BaseRefCounted</em> (indirectly through <em>BaseComponent</em>), the base class for objects with reference counting. This means that all Noesis Components are reference-counted. The first time a component is created, its reference counter is initialized to one.</p>
<div class="highlight"><pre><span class="c1">// Box inherits from BaseComponent</span>
<span class="c1">// ref = 1 - created</span>
<span class="n">Box</span><span class="o">*</span> <span class="n">box</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Box</span><span class="p">();</span>

<span class="c1">//...</span>

<span class="c1">// The component is eliminated here</span>
<span class="c1">// ref = 0 - destroyed</span>
<span class="n">box</span><span class="o">-&gt;</span><span class="n">Release</span><span class="p">();</span>
</pre></div>
<p>As shown in the example, components must not be deleted using the operator delete. Invoking the operator delete in a component destroys it automatically ignoring other possible references. The implementation of BaseRefCounted can detect this situacion in Debug asserting whenever it happens.</p>
<p>Due to the same reason, components must not be created in the stack because they are automatically destroyed when they go out of the scope creating possible dangling pointers from other existing references.</p>
<p>References to components can be manually handled using AddReference() / Release(). For example:</p>
<div class="highlight"><pre><span class="n">Box</span><span class="o">*</span> <span class="n">box0</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Box</span><span class="p">();</span>

<span class="n">Box</span><span class="o">*</span> <span class="n">box1</span> <span class="o">=</span> <span class="n">box0</span><span class="p">;</span>
<span class="n">box0</span><span class="o">-&gt;</span><span class="n">AddReference</span><span class="p">();</span>

<span class="c1">//...</span>

<span class="n">box0</span><span class="o">-&gt;</span><span class="n">Release</span><span class="p">();</span>
<span class="n">box1</span><span class="o">-&gt;</span><span class="n">Release</span><span class="p">();</span>
</pre></div>
<p>To avoid manually handling the reference counter of the component, they are usually stored inside a <a class="reference external" href="Core.Kernel.ComponentSmartPointer.html">Ptr smart pointer</a>. Through the use of Ptr, whenever a reference is destroyed or overwritten, the reference count of the object it references is decremented, and whenever one is created or copied, the reference count of the object it references is incremented.</p>
<div class="highlight"><pre><span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Box</span><span class="o">&gt;</span> <span class="n">box0</span> <span class="o">=</span> <span class="o">*</span><span class="k">new</span> <span class="n">Box</span><span class="p">();</span>
<span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Box</span><span class="o">&gt;</span> <span class="n">box1</span> <span class="o">=</span> <span class="n">box0</span><span class="p">;</span>

<span class="c1">//...</span>

<span class="c1">// box0 and box1 are automatically destroyed when they go out of scope</span>
</pre></div>
<p>As you can see in the example above, to assign a newly created component to a Ptr we use a special constructor (that internally does not increment reference counting) that receives a reference to the instance, because components are always created with 1 reference. That way, when Ptr variable goes out of scope, component reference is released and object is correctly deleted.</p>
<div class="section" id="weak-references">
<h1>Weak references</h1>
<p>One of the problems of reference counting is that cycles are not allowed. A cycle of hard references can not be automatically detected and generates leaks. To avoid cycles you should use a raw pointer. A raw pointer does not increase the reference counter.
Most of the cycle scenarios can be solved using a raw pointer. The problem with raw pointers is that they become enventually dangling pointers whenever the target instance is destroyed. If you have a scenario where this cannot be easily detected Noesis offers a mechanism that is an improvement to raw pointers: <strong>weak pointers</strong>. A weak pointer behaves exactly like a raw pointer but whenever the target object is destroyed the weak pointer becomes zero. For example:</p>
<div class="highlight"><pre><span class="n">WeakPtr</span><span class="o">&lt;</span><span class="n">Sphere</span><span class="o">&gt;</span> <span class="n">w0</span><span class="p">;</span>

<span class="p">{</span>
    <span class="n">Ptr</span><span class="o">&lt;</span><span class="n">Sphere</span><span class="o">&gt;</span> <span class="n">sphere</span> <span class="o">=</span> <span class="o">*</span><span class="k">new</span> <span class="n">Sphere</span><span class="p">(</span><span class="mf">20.0f</span><span class="p">);</span>
    <span class="n">WeakPtr</span><span class="o">&lt;</span><span class="n">Sphere</span><span class="o">&gt;</span> <span class="n">w0</span> <span class="o">=</span> <span class="n">sphere</span><span class="p">;</span>

    <span class="n">NS_UNITTEST_CHECK</span><span class="p">(</span><span class="n">w0</span><span class="p">.</span><span class="n">Lock</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">NS_UNITTEST_CHECK</span><span class="p">(</span><span class="n">w0</span><span class="p">.</span><span class="n">Lock</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
<p>To use a weak ptr you must use the <em>Lock()</em> that temporarily increases the reference counter of the target. Whenever you finish using the target it is automatically eliminated. This ensures that the target object is not destroyed while being used.</p>
</div>
<br/>
<div>
    <div class="headerbg">
        <div class="footertext" style="height:32px; background:#262626;">
            &nbsp;<br/>2013 (C) Noesis Technologies
        </div>
    </div>
</div>
</div>
</body>
</html>
